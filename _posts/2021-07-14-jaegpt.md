---
layout: post
title: Talking to myself using GPT
---
Transformer & attention models are all the hype in the machine learning community recently, so I took sometime to learn about them. As a fun project, I've decided to build a virtual version of myself (now I will finally have a friend to talk to!).

## Data preparation
The training data was prepared through [downloading my entire Facebook chat history](https://www.facebook.com/dyi/), and using a [parsing script](https://github.com/agiantwhale/jaegpt/blob/master/build_dataset.py) I wrote. There's a couple of gotchas when it comes to parsing Facebook messages data:

* Ignore chat threads where most of the language is non-English (Korean is my first language).
* Remove automated messages (A lot of *Words With Friends* requests).
* Combine consecutive messages into a single sentence.
* Set a threshold to yield a new context (I've chosen this as 50th percentile of message time delta).

Overall, the preparation pipeline looks as follows:
![GPT Data Generation Pipeline](/assets/jaegpt/data_gen.png)

The context of the model is preceding 4 messages before my reply. 3 distractors are chosen from the sent replies in the current chat for the supervision task. I haven't investigated the effects of these two parameter choices -- tuning these context and distractor parameters could be an interesting study.

The final dataset yields 29192 lines and is 11MB. I've split as 25000 lines as training set and the rest 4192 lines as the validation set. This is a fraction of the amount of data the baseline model was trained on ([DialoGPT was trained on 147M multi-turn dialogue from Reddit](https://github.com/microsoft/DialoGPT)). Regardless, I found that I was able to get reasonable results with these small datasets.

Here is the final objective distribution that we aim to model.

{% latex class=center %}
$\begin{aligned}
P(\text{Response}_{i + 1} \ \vert\ \text{Response}_{i},\ \text{Response}_{i-1},\ \cdots\ \text{Response}_{0},\ \text{Context Messages})
\end{aligned}$
{% endlatex %}


## Model architecture
The architecture is taken directly from the [HuggingFace's ConvAI2 (NeurIPS 2018) winning model](https://medium.com/huggingface/how-to-build-a-state-of-the-art-conversational-ai-with-transfer-learning-2d818ac26313). The language modeling head is making the actual token predictions, with an extra next sentence classification head added on to the hidden states of the last token to discriminate between the correct reply and a negatively sampled reply. Refer to the linked blogpost and the code for details -- the transformer network (and attention module) is a fascinating piece of work that deserves close... *attention*. For the sake of this post, you can think of the attention module as learning a masking function that focuses on each word in a given sentence (in a *fill-in-the-blank* manner).

![GPT2 Double Head Model Design](/assets/jaegpt/model_design.png)

It seems the discriminator head is designed to act as a weak supervision function to aid language modeling task (through cross learning), but **I didn't notice any noticable improvements to the main LM task without it.** More details in the following sections.


## Training implementation
I'm relying on HuggingFace's Transformer library to train the model on Google Colab's TPUs. I ran into several problems, which I mostly fixed by copy-paste engineering and customizing to suit my needs:

* Training on TPU (using [pytorch/xla](https://github.com/pytorch/xla)) requires fixed tensor sizes for speed up. This requires some additional care on preprocessing the data part (see block size optimization on parameter tuning section below). I assume this is due to TPU internally optimizing the memory layout.
* HuggingFace's Trainer (as of v4.8.2) does not support exporting multiple losses. The final optimization loss is the weighted sum of two tasks: language modeling and next sentence classification, but for final evaluation we only care about the language modeling task. A quick hack to report all three loss is in the code implementation [here](https://github.com/agiantwhale/jaegpt/blob/master/fbgpt/trainer.py).
* DialoGPT was trained without using token IDs, as a special boolean mask to indicate whether a sentence is a reply or not.

The following sections describe the parameter tuning explorations.

### Block size
This is to resolve the fixed tensor requirement with the TPU above. I wrote a script to calculate percentage of training rows that go above limit at each tokenization step. From the chart below, it seems we get a 99% yield with block size of {% latex %}$2^7 = 128${% endlatex %}.

![GPT2 Double Head Model Design](/assets/jaegpt/block_size.png)

I've updated the data processing step to pad the data to become a fixed width of 128 and ignore rows that overflow -- we are good to go.

### Epoch
I kicked off an exploratory run with epoch of 4 to see if multi-epoch training is even reasonable. Small dataset, large model size and sparse tokens seems like a recipe for overfitting, so I chose a batch size of 1 TPU (which gives us an update batch size of 8, as there are 8 TPU cores). Next sentence prediction task was not used in this run.

![Train vs Eval in Epoch 4](/assets/jaegpt/epoch_tune.png)

We seem to overfit after 1 epoch. The remainder runs in this post were trained using a single epoch.

### Task weight exploration

For a baseline, below is the entropy of a background predictors that generate a random choice for the two tasks. The DialoGPT tokenizer contains 50257 tokens, and we choose 3 distractors for the next sentence prediction tasks.

{% latex class=center %}
$\begin{aligned}
H_{\text{LM}} &= - \frac{1}{50257} + \ln(50257 \cdot e^{1/50257}) \approx 10.8249 \\
H_{\text{MC}} &= - \frac{1}{4} + \ln(4 \cdot e^{1/4}) \approx 1.3863
\end{aligned}$
{% endlatex %}

The background entropy for language modeling task is 7.8 times higher than next sentence prediction! A 50% reduction in the classification task would be considered only a 7% reduction in the language modeling task in the final loss function.

The final loss function is formulaized as 

{% latex class=center %}
$\begin{aligned}
w_{\text{LM}} \cdot L_{\text{LM}} + w_{\text{MC}} \cdot L_{\text{MC}}
\end{aligned}$
{% endlatex %}

To verify the potential improvements, I tuned the {% latex %}$w_{\text{MC}}${% endlatex %} in the combined loss to the following values. Reported metrics are eval metrics.

| {% latex %}$w_{\text{MC}}${% endlatex %} | {% latex %}$L_{\text{MC}}${% endlatex %} | {% latex %}$L_{\text{MC}} / H_{\text{MC}}${% endlatex %} | {% latex %}$L_{\text{LM}}${% endlatex %} | {% latex %}$L_{\text{LM}} / H_{LM}${% endlatex %} | {% latex %}$\text{Accuracy}${% endlatex %} |
|------|-------|-------|-------|-------|-------|
| 100  | 1.819 | 1.312 | 7.814 | 0.722 | **0.0014** |
| 10   | 1.328 | 0.958 | 5.229 | 0.483 | 0.0012 |
| 1    | **1.063** | **0.767** | 4.503 | 0.415 | 0.0002 |
| 0.1  | 1.325 | 0.956 | 4.365 | 0.403 | 0.0002 |
| 0.01 | 1.386 | 0.999 | **4.361** | **0.402** | 0.0001 |

And their corresponding learning curves:

![Eval LM Loss](/assets/jaegpt/lm_loss.png)

Using the supervision tasks shows minimal improvement to the main LM loss; rather makes it worse.

![Eval Accuracy](/assets/jaegpt/acc.png)

In constract to {% latex %}$L_{\text{LM}}${% endlatex %}, the inclusion of supervision tasks increase the LM modeling accuracy. However this isn't a good metric to optimize for, as we will be using beam search to generate responses through sampling; learning an accurate distribution of next token is more important than predicting the most likely token.

![Eval MC Loss](/assets/jaegpt/mc_loss.png)

Increasing the {% latex %}$w_{\text{MC}}${% endlatex %} parameter does not result in linear increase to MC loss, with {% latex %}$w_{\text{MC}} = 1${% endlatex %} showing the best result. In fact, a multiplier of 100 shows a worse result than random guess! I couldn't think of a reasonable explanation for this; my guess is it has to do with steep gradient magnitudes with higher {% latex %}$w_{\text{MC}}${% endlatex %}; plotting magnitude of gradient might give us a better idea here.

### Bayes hyperparameter optimization
We did some initial exploration of model architectures; now let's systematically explore the entire search space to get the best candidate. To do this, we utilize [Weights & Biases' excellent sweep utility](https://github.com/wandb/client/tree/master/wandb/sweeps), with the [config](https://github.com/agiantwhale/jaegpt/blob/master/search.yml) tuned to search the MC task weight and the learning rate. The sweep was done on a GPU instance as I ran into some issues with TPU process hanging, so with a batch size of 1.

## Conversation examples